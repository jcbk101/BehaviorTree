local node = require("modules.btree.node")
local tree = require("modules.btree.tree")

local data = require("modules.data")
local loader = require("modules.level_loader")
local cam = require "orthographic.camera" 
local CAMERA_ID = hash("/camera")

-- All Knight atlases
go.property("gladiator_knight", resource.atlas("/assets/images/boss/bosses/gladiator_knight.atlas")) 
go.property("evil_knight", resource.atlas("/assets/images/boss/bosses/evil_knight.atlas")) 
go.property("ice_knight", resource.atlas("/assets/images/boss/bosses/ice_knight.atlas")) 
go.property("gold_knight", resource.atlas("/assets/images/boss/bosses/gold_knight.atlas")) 
go.property("skeleton_knight", resource.atlas("/assets/images/boss/bosses/skeleton_knight.atlas")) 
go.property("dark_knight", resource.atlas("/assets/images/boss/bosses/dark_knight.atlas")) 


-- max speed right/left
local max_speed = 400
-- gravity pulling the player down in pixel units
local gravity = -2200
-- take-off speed when jumping in pixel units
local jump_takeoff_speed = 1000

local STATE_IDLE = 0
local STATE_CONFUSED = 1
local STATE_DEAD = 2
local STATE_STAGING = 3
local STATE_CHARGING = 4
local STATE_INTRO = 5
local STATE_PURSUING = 6
local STATE_FALL = 7
local STATE_HURT = 8
local STATE_JUMP = 9
local STATE_DEFEND = 10
local STATE_DEFLECT = 11
local STATE_WALK = 12
local STATE_HIT_WALL = 13
local STATE_TRANSITION = -1


-- Bit values
local THROW_WEAPON = 0x01
local THROW_BOMB = 0x02
local STAB_ATTACK = 0x04
local SMASH_ATTACK = 0x08
local CHARGE_PLAYER = 0x10
local CAN_DEFEND = 0x20
local CAN_DEFLECT = 0x40


go.property("sprite", hash(""))
go.property("message", nil)
go.property("onCommand", hash(""))
go.property("path_id", -1)
go.property("home_id", -1)
go.property("start_stage", -1)
go.property("visible", true)
go.property("weapon_spin", false)

-- Start:Properties that need to be accessible within BT
go.property("ground_contact", false)
go.property("is_enabled", false)
go.property("direction", -1)
go.property("speed", 2.0)
go.property("hit", false)
go.property("hp", 3)
-- End:Properties that need to be accessible within BT

go.property("action", nil)
go.property("status", 0)


---------------------------------
--
---------------------------------
local function showJumpDust( action )

	local size = go.get("#sprite", "size")
	local pos = go.get_position()
	factory.create( "#feet_dust", pos, nil, 
	{
		sprite = hash(action),
		parent_size = size,
		size = vmath.vector3(256, 114, 0)
	}, 1)
end


------------------------------------------
-- 
------------------------------------------
local function handle_obstacle_contact(self, normal, distance)

	local comp = vmath.vector3()

	if distance > 0 then
		-- First, project the accumulated correction onto
		-- the penetration vector
		local proj = vmath.project(self.correction, normal * distance)
		if proj < 1 then
			-- Only care for projections that do not overshoot.
			comp = (distance - distance * proj) * normal
			-- Apply compensation
			go.set_position(go.get_position() + comp)
			-- Accumulate correction done
			self.correction = self.correction + comp
		end
	end

	-- collided with a wall
	--if math.floor(math.abs(comp.x)) ~= 0.0 and not self.is_pursuing then	
	if math.floor(math.abs(comp.x)) ~= 0.0 then	
		-- Collided with a wall
		--self.wall_contact = true
		--if self.is_charging then
		if self.status == STATE_CHARGING then
			-- Enemy bangs up againsth the wall, 
			-- falls down and resets  facin the player			
			stateHitWall(self)
		end
	end

	-- collided with the ground
	-- stop vertical movement
	--print(normal.y)
	if normal.y > 0.7 then
		self.ground_contact = true
		--self.velocity.y = 0
		self.canJump = true
	end

	-- collided with the ceiling
	-- stop vertical movement
	-- if normal.y < -0.7 then
	-- 	print("Collider: shit!")
	-- 	self.velocity.y = 0
	-- end
end



---------------------------------
-- 
---------------------------------
local function flash(self)

	if self.invulnerable > 0 then
		self.invulnerable = self.invulnerable - 1
		--
		if 	(self.invulnerable % 10) < 3 then 
			--go.set("#sprite", "tint.w", 1)
			go.set("#sprite", "flash.x", 1)
		else 
			go.set("#sprite", "flash.x", 0)
		end
	else
		go.set("#sprite", "flash.x", 0)
	end
end


---------------------------------
--
---------------------------------
local function update_animations(self)

	if self.status == STATE_DEAD or self.status == STATE_CONFUSED then return end

	--print("GRD: " .. tostring(self.ground_contact))
	if self.ground_contact then

	else
		--print("VY: " ..self.velocity.y)
		if self.velocity.y < 0 then
			stateFall(self)
			--play_animation(self, hash(self.enemy .. "_fall"))
		end
	end
end


---------------------------------
-- 
---------------------------------
local function flashWhackEffect(self, points)

	self.whack = factory.create("/enemies#whack_effect", go.get_position(), nil,
	{
		flashes = 1,
		points = points
	}, 2 ) -- twice the normal size

	go.set_parent(self.whack, go.get_id(), true)
end


--------------------------------------
-- Execute the script
--------------------------------------	
local function callCommand(self)

	local object = loader.objects["obj"..self.path_id]
	local url

	-- Collection Factories require extra data
	if type(object) == "table" then
		object = loader.objects["obj"..self.path_id]["/base"]
	end

	url = msg.url(nil, object, "script")

	-- Sound effect
	sound.play("main:/sfx_group#claim")

	-- Scroll to the object
	timer.delay(.5, false,
	function()
		-- Protect the player while away
		go.set("/player#player_script", "cannot_control", true)
		--
		local indicator = factory.create( "/objects#indicator", vmath.vector3(), nil, nil, 1)
		msg.post(indicator, "scroll_to", 
		{ 
			start = go.get_position(), 
			dest = go.get_position(object),
			url = url,
			message = self.onCommand
		})
	end)
end




------------------------------------------
--
-- AI functions set below
--
------------------------------------------
local function buildStageTable(self)

	-- Build the list of 'Home locations'
	if self.path_id then
		local id = self.home_id
		local path_ptr = loader.objects["home_id" .. self.home_id]
		local index = 1
		local actions = 0

		self.stage_locs = {}

		while path_ptr do

			actions = path_ptr.action.actions
			path_ptr.action.actions = nil
			--	
			self.stage_locs[index] = 
			{ 
				--				id = id,
				pos = path_ptr.position, 
				actions = actions or 0,
				rules = path_ptr.action,
				timeLimit = path_ptr.timeLimit,
				direction = path_ptr.direction,
				index = index
			}

			-- Ensure correct pointer to the next item
			if path_ptr.linked_id and path_ptr.linked_id ~= -1 then
				local broken = nil

				for i = 1, #self.stage_locs do
					if self.stage_locs[i].id == path_ptr.linked_id then
						-- This will end the loop due to this item being already porcessed
						self.stage_locs[index].linked_index = i
						loader.objects["home_id" .. id] = nil
						broken = true
						break
					end
				end

				-- Trigger that the id was saved
				self.stage_locs[index].id = id

				-- Found the end
				if broken then break end

				index = index + 1
				id = path_ptr.linked_id				
				path_ptr = loader.objects["home_id" .. id]

				if path_ptr then
					self.stage_locs[index - 1].linked_index = index
				end
			else
				break
			end
		end

		-- Go to the initial stage
		for i = 1, #self.stage_locs do
			if self.stage_locs[i].id == self.start_stage then
				--stateSetTheStage(self, i)
				self.intro_stage = i
				break
			end
		end
	end	

	------------------------------------
	-- Get some counters started
	------------------------------------
	--resetThrowCounter(self, 2)
end




----------------------------------------------------------------------------------------
--
--
-- Code that handles boss actions
-- 
--
----------------------------------------------------------------------------------------
---------------------------------
-- 
---------------------------------
function changeDirection(self, direction )

	-- Everything switches
	self.direction = direction
	go.set(".", "scale.x", direction)	

	-- Physics collider
	physics.set_hflip("#is_kinematic", direction == -1 and true or false)
	physics.set_hflip("#attack", direction == -1 and true or false)


	-- Health bar needs to remain in correct direction
	go.set("#health", "scale.x", direction)
end


---------------------------------
-- 
---------------------------------
function faceThePlayer(self, location)

	local pos = go.get_position()
	local ppos = location or go.get_position("/player")
	local dir = (ppos.x - pos.x) < 0 and -1 or 1

	changeDirection(self, dir)
end


------------------------------------
--
------------------------------------
function checkForPursuit(self)

	if self.is_dying then 
		self.move.x = 0
		return
	end

	--------------------------------
	local pos = go.get_position()
	local ppos = go.get_position("/player")
	local frozen = go.get("/player#player_script", "frozen")
	--local confused = go.get("/player#player_script", "confused")
	local paralyzed = go.get("/player#player_script", "paralyzed")	

	-- Within pursuing space
	if ( frozen or paralyzed ) then

		-- Must be one of these states
		if self.status == STATE_IDLE or self.status == STATE_WALK then	

			-- Make the "tick" sound as if player detected
			--if self.getting_angry or self.is_pursuing then
			if self.getting_angry or self.status == STATE_PURSUING then
				resetThrowCounter(self)
				return
			end

			-- First time here
			sound.play("main:/sfx_group#shuriken", nil,
			function()
				sound.play("main:/sfx_group#boss_charge")
			end)

			------------------------------------
			self.getting_angry = true
			timer.delay(.5, false,
			function()
				local dir = (ppos.x - pos.x) < 0 and -1 or 1

				self.getting_angry = nil				
				self.status = STATE_PURSUING
				self.direction = dir
				-- change the direction
				changeDirection(self, self.direction )

				-- Angry RED			
				go.set("#sprite", "tint", vmath.vector4(1, 0, 0, 1))
				-- Make the boss run
				resetThrowCounter(self)
				stateRun(self, self.pursuitSpeed)
			end)
		end
		----------------------------------------
		-- End pursuit
		----------------------------------------
		--elseif self.is_pursuing then
	elseif self.status == STATE_PURSUING then

		-- Stop running immediately
		self.move.x = 0
		stateIdle(self)
		-- Make sure the 'Stage jump' counter is disabled for a bit longer
		if self.time_limit then
			self.time_limit = self.time_limit + 1.5
		end		

		-- Standard color
		go.set("#sprite", "tint", vmath.vector4(1, 1, 1, 1))

		-- -- Delay this action a tad
		timer.delay(.5, false,
		function()
			local blink = go.get("/player#player_script", "invulnerable")
			if blink <= 0 then
				stateGotoTheStage(self)
			end
		end)
	end
end


---------------------------------
-- Life status
---------------------------------
local function checkLifeStatus(self)

	self.health_bar = self.health_bar - self.tick
	if self.health_bar < 0 then self.health_bar = 0 end

	---------------------------------
	go.animate("#health", "value", go.PLAYBACK_ONCE_FORWARD, vmath.vector4((self.health_bar / 100.0), 0, 0, 0), go.EASING_OUTSINE, FADE_TIME * 2)

	if self.health_bar <= 0 then
		self.status = STATE_DEAD
		stateDie(self)

		-- Freeze the player and protect them
		msg.post("/player", "set_control", { enable = false, animation = "idle" } )
		-- Play boss defeated sound
		sound.play("main:/sfx_group#boss_die", nil, 
		function()
			if self.path_id then				
				-- IF a linked target exist, execute the code
				callCommand(self)
			end
		end)
	else
		self.boss_hit = nil
		-- Keep the boss safe for a few as he is getting
		-- Angry and will charge the player
		--self.invulnerable = 300	

		-- Make the Boss angry, but not 'RED' angry. 
		-- Charge the player and attack.
		-- If player evades, run into the wall, etc and turn around
		------------------------------------
		-- Slam sword 3 times, then attack
		stateCharge(self, true)
	end
end


---------------------------------
-- Handle AI for when to attack
-- and what type of attack to 
-- perform
---------------------------------
function play_animation(self, anim, return_fps, callback)

	-- Only play animations which are not already playing
	if self.anim ~= anim then
		-- Tell the sprite to play the animation
		sprite.play_flipbook("#sprite", anim, callback)
		-- Remember which animation is playing
		self.anim = anim
	end

	-- Return only when requested
	if return_fps then
		local path = go.get("#sprite", "image")
		local ts_info = resource.get_atlas(path)

		for i = 1, #ts_info.animations do
			if hash(ts_info.animations[i].id) == anim then
				return go.get("#sprite", "frame_count"), ts_info.animations[i].fps
			end
		end

		return go.get("#sprite", "frame_count"), 10 -- Default of 10 Fps
	end
end


---------------------------------
-- 
---------------------------------
function attackThePlayer(self)

	local random = math.random(2)
	local anim = hash(self.anim)

	if anim == hash(self.enemy .. "_idle") then
		-- Idle status allows for stab or smash
		if random == 1 then
			-- If not active, run into player
			if bit.band(self.actions, STAB_ATTACK) > 0 then
				stateStab(self, true) 
			end
		else
			-- If not active, run into player
			if bit.band(self.actions, SMASH_ATTACK) > 0 then
				stateSmash(self, true)
			end
		end

	elseif anim == hash(self.enemy .. "_walk") then
		--self.is_charging = nil
		-- Walk status allows for stab or walk attack
		-- If hit made, stop running and idle
		if random == 1 then
			-- If not active, run into player
			if bit.band(self.actions, STAB_ATTACK) > 0 then
				self.move.x = 0				
				stateStab(self, true)
			end			
		else
			self.move.x = 0			
			stateAttackWalk(self, true)
		end

	elseif anim == hash(self.enemy .. "_run") then
		-- Run status allows for stab or run attack
		-- If hit made, stop running and idle, then jump

		if random == 1 and not self.is_charging then
			-- If not active, run into player
			if bit.band(self.actions, SMASH_ATTACK) > 0 then
				self.move.x = 0								
				stateSmash(self, true, 
				function()
					stateGotoTheStage(self, 0.25)
				end)
			else
				stateTackle(self, true,
				function()
					stateGotoTheStage(self, 0.25)
				end)
			end			
		else
			self.move.x = 0						
			stateAttackRun(self, true, 
			function()
				stateGotoTheStage(self, 0.25)
			end)
		end		
	end	
end


---------------------------------
-- 
---------------------------------
function stateSmash(self, hurt_player, callback)

	if self.ground_contact then
		-- Shake the screen
		timer.delay(.25, false, 
		function()
			if hurt_player then
				-- Hurt the player
				msg.post("/player", "hurt", { hit = true} )
				--	msg.post("/player", "set_control", { enable = false } )
				msg.post("/player", "thrust", { direction = self.direction, force = vmath.vector3(2.5, 0, 0) } )
			end

			sound.play("main:/sfx_group#bomb_explode", { speed = 1.5 })
			cam.shake(CAMERA, 0.02, 0.25, "both", nil)
		end)

		-- Play animation 
		local frames, fps = play_animation(self, hash(self.enemy .. "_smash"), true)
		timer.delay((1.0 / fps) * frames, false,
		function()
			if hurt_player then
				-- Delay control for a bit. Bigger hit pauses longer
				timer.delay(0.5, false, 
				function()
					msg.post("/player", "set_control", { enable = true } )
				end)			
			end

			-- Make the enemy idle for now
			stateIdle(self)

			-- Sometimes you need a call back
			if callback and type(callback) == "function" then
				callback()
			end
		end)
	end	
end


---------------------------------
-- 
---------------------------------
function stateStab(self, hurt_player, callback)

	if self.ground_contact then
		-- Shake the screen
		timer.delay(.25, false, 
		function()
			if hurt_player then
				-- Hurt the player
				msg.post("/player", "hurt", { hit = true} )
				msg.post("/player", "thrust", { direction = self.direction, force = vmath.vector3(2, 0, 0) } )
			end

			--print("Stab!!!")
			sound.play("main:/sfx_group#boss_stab", { gain = .5} )
			cam.shake(CAMERA, 0.015, 0.15, "both", nil)			
		end)

		-- Play animation 
		--		play_animation(self, hash(self.enemy .. "_stab"), true,
		local frames, fps = play_animation(self, hash(self.enemy .. "_stab"), true)
		timer.delay((1.0 / fps) * frames, false,
		function()
			if hurt_player then
				-- Delay control for a bit. Bigger hit pauses longer
				timer.delay(0.5, false, 
				function()
					msg.post("/player", "set_control", { enable = true } )
				end)			
			end

			-- Make the enemy idle for now			
			stateIdle(self)

			-- Sometimes you need a call back
			if callback and type(callback) == "function" then
				callback()
			end			
		end)
	end	
end


---------------------------------
-- 
---------------------------------
function stateTackle(self, hurt_player, callback)

	if self.ground_contact then
		-- Shake the screen
		timer.delay(.25, false, 
		function()
			if hurt_player then
				-- Hurt the player
				msg.post("/player", "hurt", { hit = true } )
				msg.post("/player", "thrust", { direction = self.direction, force = vmath.vector3(2, 0, 0) } )
			end

			sound.play("main:/sfx_group#boss_hurt", { gain = .5} )
			cam.shake(CAMERA, 0.015, 0.15, "both", nil)			
		end)

		-- Play animation 
		local frames, fps = play_animation(self, hash(self.enemy .. "_tackle"), true)
		timer.delay((1.0 / fps) * frames, false,
		function()
			if hurt_player then
				-- Delay control for a bit. Bigger hit pauses longer
				timer.delay(0.5, false, 
				function()
					msg.post("/player", "set_control", { enable = true } )
				end)			
			end

			-- Make the enemy idle for now			
			stateIdle(self)

			-- Sometimes you need a call back
			if callback and type(callback) == "function" then
				callback()
			end			
		end)
	end	
end


---------------------------------
-- 
---------------------------------
function stateAttackRun(self, hurt_player, callback)

	if self.ground_contact then
		-- Shake the screen
		timer.delay(.2, false, 
		function()
			-- Hurt the player
			msg.post("/player", "hurt", { hit = true} )
			--	msg.post("/player", "set_control", { enable = false } )
			msg.post("/player", "thrust", { direction = self.direction, force = vmath.vector3(4, 0, 0) } )
			--sound.play("main:/sfx_group#boss_sword")
			sound.play("main:/sfx_group#bomb_explode", { speed = 1.5, gain = .75 })
			cam.shake(CAMERA, 0.015, 0.25, "both", nil)
		end)

		-- Play animation 
		--play_animation(self, hash(self.enemy .. "_attack_run"), true,
		local frames, fps = play_animation(self, hash(self.enemy .. "_attack_run"), true)
		timer.delay((1.0 / fps) * frames, false,
		function()
			-- Delay control for a bit. Bigger hit pauses longer
			timer.delay(0.5, false, 
			function()
				msg.post("/player", "set_control", { enable = true } )
			end)			

			-- Make the enemy idle for now
			stateIdle(self)

			-- Sometimes you need a call back
			if callback and type(callback) == "function" then
				callback()
			end						
		end)
	end	
end

---------------------------------
-- 
---------------------------------
function stateAttackWalk(self, hurt_player,callback)

	if self.ground_contact then
		-- Shake the screen
		timer.delay(.2, false, 
		function()
			-- Hurt the player
			msg.post("/player", "hurt", { hit = true} )
			--	msg.post("/player", "set_control", { enable = false } )
			msg.post("/player", "thrust", { direction = self.direction, force = vmath.vector3(3, 0, 0) } )
			--sound.play("main:/sfx_group#boss_sword")
			sound.play("main:/sfx_group#bomb_explode", { speed = 1.5, gain = .5 })
			cam.shake(CAMERA, 0.01, 0.25, "both", nil)
		end)

		-- Play animation 
		--play_animation(self, hash(self.enemy .. "_attack_walk"), true,
		local frames, fps = play_animation(self, hash(self.enemy .. "_attack_walk"), true)
		timer.delay((1.0 / fps) * frames, false,
		function()
			-- Delay control for a bit. Bigger hit pauses longer
			timer.delay(0.5, false, 
			function()
				msg.post("/player", "set_control", { enable = true } )
			end)			

			-- Make the enemy idle for now
			stateIdle(self)

			-- Sometimes you need a call back
			if callback and type(callback) == "function" then
				callback()
			end						
		end)
	end	
end

---------------------------------
-- 
---------------------------------
function stateConfused(self)

	-- Does not matter the status as long as not dead
	-- No double confused
	if self.confuse_timer == nil and self.status ~= STATE_DEAD and self.status ~= STATE_CONFUSED then

		-- Stop moving, show confusion
		self.move.x = 0
		self.status = STATE_CONFUSED

		-- Play animation - Looping
		play_animation(self, hash(self.enemy .. "_confused"))
		sound.play("main:/sfx_group#boss_hurt", { speed = .5 } )

		-- Remain confused for 8 seconds
		self.confuse_timer = timer.delay(8, false,
		--self.confuse_timer = timer.delay(1, false,
		function(self, handle, time_elapsed)
			timer.cancel(handle)
			self.confuse_timer = nil
			self.triggered = nil
			--
			if self.status ~= STATE_DEAD then
				stateIdle(self, true)
			end
		end)
	end	
end


---------------------------------
-- 
---------------------------------
function stateDefend(self, type)

	-- Can the player defend
	if bit.band(self.actions, CAN_DEFEND) > 0 then

		self.status = STATE_DEFEND

		--	if self.ground_contact then
		local random = math.random(100)
		local prob = (1.0 - (self.rules.defend_probability)) * 100

		--print("Defend: " .. random, prob)

		-- Defend if true
		if random > prob then
			-- Play animation, but only on the ground 
			--play_animation(self, hash(self.enemy .. "_defend"), nil,
			local frames, fps = play_animation(self, hash(self.enemy .. "_defend"), true)
			timer.delay((1.0 / fps) * frames, false,
			function()
				if self.staus ~= STATE_CONFUSED then
					stateIdle(self)
				end
			end)
		else
			-- Can only bombs, efaults to hurt
			stateHurt(self, type)
		end	

		-- Default's to Hurt
	else
		stateHurt(self, type)
	end
end


---------------------------------
-- 
---------------------------------
function stateDeflect(self, type, url)

	-- Prevent double contact
	--if self.is_hurting then return end

	-- Can the player defend
	if bit.band(self.actions, CAN_DEFLECT) > 0 then

		self.status = STATE_DEFLECT

		--	if self.ground_contact then
		local random = math.random(100)
		local prob = (1.0 - (self.rules.deflect_probability)) * 100

		-- Defend if true
		if random > prob then
			--if random >= 0 then
			-- Slight delay for effect
			timer.delay(0.2, false,
			function()
				sound.play("main:/sfx_group#shuriken")
				msg.post(url, "deflect", { direction = self.direction } )
			end)

			-- Play animation, but only on the ground 
			local frames, fps = play_animation(self, hash(self.enemy .. "_smash"), true)
			timer.delay((1.0 / fps) * frames, false,
			function()
				if self.status ~= STATE_CONFUSED then
					stateIdle(self, true)
				end
			end)
		else
			-- No deflection, Boss gets hurt but ONLY from shuriken
			-- Bomb not deflected so return to Idle
			stateIdle(self, true)
		end
	else
		-- No deflection, Boss gets hurt but ONLY from shuriken
		-- Bomb not deflected so return to Idle
		stateIdle(self, true)				
	end
end

---------------------------------
-- 
---------------------------------
function stateDie(self)

	-- HP must be depleted
	if self.hp then
		-- Play animation - Looping
		play_animation(self, hash(self.enemy .. "_die"))
		sound.play("main:/sfx_group#boss_die")				
	end	
end


---------------------------------
-- 
---------------------------------
function stateHurt(self, weapon)

	-- If a bomb was used, set confuse to true
	-- No double confused allowed. Just hurt at that point
	if weapon and self.status ~= STATE_CONFUSED then
		-- Must reset the throw counter to prevent rouge tosses
		resetThrowCounter(self)

		-- Shuriken takes 3 hits to stun
		if weapon == hash("shuriken") then
			self.shurikenHits = self.shurikenHits + 1
			self.status = STATE_HURT

			-- Show weapon contact
			flashWhackEffect(self, nil)
			self.invulnerable = 50

			-- Show the effects of a shuriken making contact
			if self.shurikenHits < 3 then	
				sound.play("main:/sfx_group#boss_hurt")	

				local frames, fps = play_animation(self, hash(self.enemy .. "_hurt"), true)
				--
				timer.delay((1.0 / fps) * frames, false,
				function()
					if self.status ~= STATE_CONFUSED then
						stateIdle(self)
					end
				end)
			end
		end

		-- Test for confusion		
		if (weapon == hash("bomb") or self.shurikenHits >= 3) and self.status ~= STATE_CONFUSED then
			self.shurikenHits = 0
			-- Will be confused for a bit
			stateConfused(self)
		end		
	elseif not weapon then
		---------------------------------
		-- Main way to defeat the boss
		-- Is head stump after daze
		---------------------------------
		-- Must reset the throw counter to prevent rouge tosses
		resetThrowCounter(self)

		sound.play("main:/sfx_group#stomp")
		--play_animation(self, hash(self.enemy .. "_hurt"), nil,
		local frames, fps = play_animation(self, hash(self.enemy .. "_hurt"), true)

		timer.delay((1.0 / fps) * frames, false,
		function()		
			if self.confuse_timer then
				--timer.cancel(self.confuse_timer)
				self.triggered = true
				timer.trigger(self.confuse_timer)
				self.confuse_timer = nil
			end

			--self.is_hurting = nil
			checkLifeStatus(self)		
		end)
	end
end

---------------------------------
-- 
---------------------------------
function stateIdle(self, facePlayer)

	play_animation(self, hash(self.enemy .. "_idle"))
	-- Stop movement
	self.move.x = 0
	self.status = STATE_IDLE

	if facePlayer then
		faceThePlayer(self, go.get_position("/player"))
	end
end


---------------------------------
-- 
---------------------------------
function stateJump(self, spring, pixels)

	-- Stop and check credentials
	if self.status == STATE_CONFUSED or self.status == STATE_DEAD then 
		return 
	end

	---------------------------------
	-- only allow jump from ground
	---------------------------------
	if self.ground_contact then
		-- Must reset the throw counter to prevent rouge tosses
		resetThrowCounter(self)

		self.status = STATE_JUMP

		if pixels then
			self.velocity.y = pixels
		else
			self.velocity.y = jump_takeoff_speed * ((spring and spring > 0) and spring or 1)
		end

		-- Play animation
		--play_animation(self, hash(self.enemy .. "_jump"), nil,
		local frames, fps = play_animation(self, hash(self.enemy .. "_jump"), true)
		timer.delay((1.0 / fps) * frames, false,
		function(self, message_id, message, sender)
			self.ground_contact = false
			-- Switch to fall animation
			stateFall(self)
		end)

		sound.play("main:/sfx_group#jump", { speed = .5 } )
	end	
end


---------------------------------
-- 
---------------------------------
function stateFall(self)

	-- Must reset the throw counter to prevent rouge tosses
	resetThrowCounter(self)

	play_animation(self, hash(self.enemy .. "_fall"))
	--self.status = STATE_FALL

end


---------------------------------
-- 
---------------------------------
function stateWalk(self, speed)

	---------------------------------
	-- Only allow running when grounded
	---------------------------------
	if self.ground_contact then

		-- Must reset the throw counter to prevent rouge tosses
		resetThrowCounter(self)

		self.status = STATE_WALK 

		-- Play animation - looping
		play_animation(self, hash(self.enemy .. "_walk"))
		-- Set the running speed
		self.move.x = speed * self.direction		
	end			
end


---------------------------------
-- 
---------------------------------
function stateRun(self, speed)
	---------------------------------
	-- Only allow running when grounded
	---------------------------------
	if self.ground_contact then
		-- Play animation - Looping
		play_animation(self, hash(self.enemy .. "_run"))
		-- Set the running speed
		self.move.x = speed * self.direction
	end	
end


---------------------------------
-- 
---------------------------------
function stateThrowBomb(self, target_pos )

	-- MUST be NORMAL (Idle)
	if self.status ~= STATE_IDLE then 
		-- Reset time just to prevent false throw
		resetThrowCounter(self)
		return 
	end

	-- Should be facing the player
	faceThePlayer(self, go.get_position("/player"))

	-- Create the correct bomb, and showing being thrown from the top of the swing
	local pos = go.get_position()
	local bomb = factory.create( "#bomb", vmath.vector3(pos.x, pos.y + 90, pos.z + 0.001), nil,
	{ 
		target_pos = target_pos,
		sprite = hash(self.enemy),
		parent = go.get_id(),
		delay = 0.44
	},	1)

	-- The bomb type to use
	local url = msg.url(nil, bomb, "script")
	msg.post(url, "setBomb", { bomb_name = self.enemy } )
	--msg.post(url, "setBomb", { bomb_name = "dark" } )

	-- Play animation 
	--play_animation(self, hash(self.enemy .. "_throw"), true,
	local frames, fps = play_animation(self, hash(self.enemy .. "_throw"), true)
	timer.delay((1.0 / fps) * frames, false,
	--play_animation(self, hash(self.enemy .. "_throw"), true, 
	function()
		if self.status ~= STATE_CONFUSED then
			stateIdle(self)
		end
	end)	
end


---------------------------------
-- 
---------------------------------
function stateThrowWeapon(self, target_pos )

	-- MUST be NORMAL (Idle)
	if self.status ~= STATE_IDLE then 
		-- REset time just to prevent false throw
		resetThrowCounter(self)
		return 
	end

	-- Should be facing the player
	faceThePlayer(self, go.get_position("/player"))

	-- Create the correct bomb, and showing being thrown from the top of the swing
	local pos = go.get_position()
	local weapon = factory.create( "#weapon", vmath.vector3(pos.x, pos.y + 90, pos.z + 0.001), nil,
	{ 
		sprite = hash(self.enemy),
		spin = self.weapon_spin,
		delay = 0.44
	},	1)

	-- The bomb type to use
	local url = msg.url(nil, weapon, "script")
	--msg.post(url, "setBomb", { bomb_name = self.enemy } )
	--msg.post(url, "setWeapon", { weapon_name = self.enemy, target_pos = target_pos } )
	msg.post(url, "setWeapon", { weapon_name = "dark", target_pos = target_pos } )

	-- Play animation 
	--play_animation(self, hash(self.enemy .. "_throw"), true,
	local frames, fps = play_animation(self, hash(self.enemy .. "_throw"), true)
	timer.delay((1.0 / fps) * frames, false,
	--play_animation(self, hash(self.enemy .. "_throw"), true,
	function()
		if self.status ~= STATE_CONFUSED then
			stateIdle(self)
		end
	end)	
end


---------------------------------
-- 
---------------------------------
function resetThrowCounter(self, initial)
	if not initial then
		initial = 0
	end

	if bit.band(self.actions, THROW_BOMB) > 0 then 
		self.throw_counter = math.random(self.rules.throw_bomb_interval, self.rules.throw_bomb_interval + 1)		
		--print("Boss: Now throwing bombs...")
	elseif bit.band(self.actions, THROW_WEAPON) > 0 then 
		self.throw_counter = math.random(self.rules.throw_weapon_interval, self.rules.throw_weapon_interval + 1)
		--print("Boss: Now throwing weapons...")
	else
		self.throw_counter = nil
	end
end


---------------------------------
-- 
---------------------------------
function stateCharge(self, callback)

	-- To prevent accidental attacks on the character after a stomp to the boss
	-- Disable '#Attack" by trigger until the boss begins the charge 
	--msg.post("#attack", "disable")
	-- Set the state
	self.status = STATE_CHARGING

	-- Must reset the throw counter to prevent rouge tosses
	resetThrowCounter(self)
	-- Make sure the 'Stage jump' counter is disabled for a bit longer
	if self.time_limit then
		self.time_limit = self.time_limit + 1.5
	end

	-- Process charge scene
	timer.delay(.75, false, 
	function()
		self.co = coroutine.create(
		function()
			-- Loop three times
			for i = 1, 3 do

				stateSmash(self, nil,
				function()
					--print("stateCharge: coroutine")
					coroutine.resume(self.co)
				end)

				-- Must retain this state
				self.status = STATE_CHARGING

				-- Wait before calling the loop again
				coroutine.yield()
			end

			-- Must retain this state
			self.status = STATE_CHARGING

			-- Now make the angry bastard run towards the player
			faceThePlayer(self)

			-- Play charge sound then chase the player
			sound.play("main:/sfx_group#boss_charge")
			-- Enable attacks by trigger again
			--msg.post("#attack", "enable")

			-- Flag to know what to do next
			--self.is_charging = true
			stateRun(self, self.runSpeed * 1.5)
		end)

		------------------------------------
		-- Get the party started
		------------------------------------
		coroutine.resume(self.co)
	end)
end


---------------------------------
-- 
---------------------------------
function stateHitWall(self, callback)

	-- Must reset the throw counter to prevent rouge tosses
	resetThrowCounter(self)

	--	timer.delay(.25, false, 
	--function()
	self.hitwall_co = coroutine.create(
	function()
		-- Play sound of boss hurt
		sound.play("main:/sfx_group#boss_hurt" )

		-- Animate falling back while playing death animation for effect
		local pos = go.get_position()			
		go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, pos.x + (150 * (-self.direction)), go.EASING_OUTQUAD, FADE_TIME)
		self.move.x = 0

		-- Set status STATE_CONFUSED for a sec just for animation purposes. 
		-- "update_animation" will kill the death animation without STATE_DEAD or STATE_CONFUSED
		self.status = STATE_HIT_WALL

		-- Freebie!
		giveGift(self)

		-- Do a little jump, set ground flag to false
		self.velocity.y = math.sqrt(2 * 192 * math.abs(gravity))
		self.ground_contact = false

		-- Death animation for effect, a little fast
		play_animation(self, hash(self.enemy .. "_hurt"))

		-- Wait for a ground hit
		coroutine.yield()

		-- Stay on the ground a few for effect. Blink a little
		self.invulnerable = 50
		--timer.delay(.5, false,
		--function()
		--self.status = STATE_IDLE
		-- Now make the boss stand up and be confused
		local random = math.random(10)

		-- Don't always confuse the boss
		--if random > 7 then
		if random == 5 then
			stateConfused(self) 
		else
			timer.delay(1, false,
			function()
				stateGotoTheStage(self)
			end)

			stateIdle(self)
		end
		--end)

		-- Delete the coroutine
		self.hitwall_co = nil
	end)

	------------------------------------
	-- Get the party started
	------------------------------------
	coroutine.resume(self.hitwall_co)
	--end)
end


local function split2Actions(self, actions)
	local acts = { "throw_weapon", "throw_bomb", "stab", "smash", "charge", "defend", "deflect" }
	local index = 1
	local shf = 1
	local str = ""

	for i = 1, #acts do
		if bit.band(actions, shf) then
			str = str .. acts[i] .. ", "
		end
		--
		shf = bit.lshift(shf,1)
	end
	return str
end


---------------------------------
-- Return largest value in list
---------------------------------
local function getLargest(list)
	local big = 0
	local index = 0

	for i = 1,  #list do
		if list[i] > big then
			big = list[i]
			index = i
		end
	end						

	list[index] = -1
	return index
end


---------------------------------
-- Go to a stage
---------------------------------
function stateSetTheStage(self, stage)

	-- Return 'stage position' via jump (if table exist)
	if self.stage_locs and stage then

		self.stage_co = coroutine.create(
		function()
			-- Boss requested a particular stage to transition to
			local stage_pos = self.stage_locs[stage].pos
			local stage_actions = self.stage_locs[stage].actions
			local stage_rules = self.stage_locs[stage].rules
			local direction = self.stage_locs[stage].direction -- current not used
			local timeLimit = self.stage_locs[stage].timeLimit
			local stage_index = self.stage_locs[stage].linked_index

			self.boss_hit = nil
			--self.is_hurting = nil

			-- Set the velocity info. X movement will reset afterwards. No need to save
			self.velocity = (stage_pos - go.get_position())
			self.velocity.y = self.velocity.y + math.abs(gravity * 0.5)
			-- Flag Boss off the ground
			self.ground_contact = false
			-- Set the current state
			self.status = STATE_STAGING

			-- Show a jumping animation
			play_animation(self, hash(self.enemy .. "_jump"))
			sound.play("main:/sfx_group#jump", { speed = .5 } )	

			-- Show the dust cloud near the feet
			showJumpDust("jump")

			-- Wait for the boss to touch ground
			coroutine.yield()

			-- Show the dust cloud near the feet
			showJumpDust("land")

			cam.shake(CAMERA, 0.02, 0.25, "both", nil)
			sound.play("main:/sfx_group#bomb_explode", { gain = .35} )

			-- Set the Boss in the proper position
			-- Do so smoothly
			go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, stage_pos.x, go.EASING_OUTQUAD, FADE_TIME, 0)			

			-- Set new actions / rules /time limits
			self.rules = stage_rules
			self.actions = stage_actions
			self.time_limit = (timeLimit > 0) and timeLimit or nil
			self.stage_index = stage_index
			--print("Set_Stage, time: ", self.time_limit)

			-- Determine projectile type
			resetThrowCounter(self)
			-- Face the player
			faceThePlayer(self)						
			-- Idle the boss on this stage
			stateIdle(self)
			--
			self.stage_co = nil
		end)

		coroutine.resume(self.stage_co)
	end
end

---------------------------------
-- Return to a stage
---------------------------------
function stateGotoTheStage(self, delay)

	if self.is_running_goto == true or self.status == STATE_CONFUSED then return end

	-- Return 'stage position' via jump (if table exist)
	if self.stage_locs then

		self.is_running_goto = true

		---------------------------------------------------------------------
		-- Use a length buffer to store all distances from the player
		-- The 2 longest distances will be what the random value jumps to
		-- ONLY if stage positions > 2
		---------------------------------------------------------------------
		local lens = {}
		local stage_choice = 0

		-------------------------------
		--
		-------------------------------		
		if #self.stage_locs > 2 then
			local big = {}
			local pos = go.get_position("/player")

			-- Find the two largest
			for i = 1,  #self.stage_locs do
				lens[i] = vmath.length(self.stage_locs[i].pos - pos)
			end						
			big[1] = getLargest(lens) -- the selection is removed
			big[2] = getLargest(lens)
			stage_choice = big[math.random(#big)]

		elseif #self.stage_locs > 0 then
			-- 1 or 2 stages
			stage_choice = math.random(#self.stage_locs)
		else
			-- No where to return
			return
		end

		--falling thru floor on stage 2
		-------------------------------
		--
		-------------------------------
		--stage_choice = 3
		local stage_pos = self.stage_locs[stage_choice].pos
		local stage_actions = self.stage_locs[stage_choice].actions
		local stage_rules = self.stage_locs[stage_choice].rules
		local direction = self.stage_locs[stage_choice].direction -- current not used
		local timeLimit = self.stage_locs[stage_choice].timeLimit
		local stage_index = self.stage_locs[stage_choice].linked_index

		self.stage_co = coroutine.create(
		function()
			-- Set the current state to sleep or wait
			self.status = STATE_TRANSITION
			self.boss_hit = nil
			--self.is_hurting = nil

			-- Sleep a bit
			timer.delay(delay or 0.1, false, function()
				--timer.delay(0.1, false, function()
				coroutine.resume(self.stage_co)
			end)

			-- Wait for sleep timer to complete
			coroutine.yield()

			-------------------------------
			-- Execute the process
			-------------------------------
			-- Set the velocity info. X movement will reset afterwards. No need to save
			self.velocity = (stage_pos - go.get_position())
			self.velocity.y = self.velocity.y + math.abs(gravity * 0.5)
			-- Flag Boss off the ground
			self.ground_contact = false

			-- DEBUG ONLY
			update_dots(self, go.get_position())

			-- Face jumping direction
			faceThePlayer(self, stage_pos)

			-- Execute the jump
			--stateJump(self)
			self.status = STATE_STAGING
			sound.play("main:/sfx_group#jump",{ speed = .5 } )
			-- Show a jumping animation
			play_animation(self, hash(self.enemy .. "_jump"))
			showJumpDust("jump")

			-- Wait for the boss to touch ground
			coroutine.yield()

			showJumpDust("land")			
			-- Shake screen and landing sound
			cam.shake(CAMERA, 0.02, 0.25, "both", nil)
			sound.play("main:/sfx_group#bomb_explode", { gain = .35} )

			-- Set the Boss in the proper position
			-- Do so smoothly
			go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, stage_pos.x, go.EASING_OUTQUAD, FADE_TIME, 0)

			-------------------------------------------
			-- Set the current state to transitioning
			-- to manually process moves
			-------------------------------------------
			self.status = STATE_TRANSITION

			-- Set new actions / rules /time limits
			self.rules = stage_rules			
			self.actions = stage_actions
			self.time_limit = (timeLimit > 0) and timeLimit or nil
			self.stage_index = stage_index
			--print("Goto_Stage, time: ", self.time_limit)
			-- DEBUG ONLY
			--print("[" .. stage_choice .. "]", split2Actions(self, stage_actions)) -- DEBUG function

			-- Determine projectile type
			resetThrowCounter(self)
			-- Face the player
			faceThePlayer(self)
			-- Restore the normal state
			stateIdle(self)

			-- Kill it for good
			self.stage_co = nil	
			self.is_running_goto = nil					
		end)

		-- Get the party started
		coroutine.resume(self.stage_co)
	end
end


---------------------------------
-- Provide a gift
---------------------------------
function giveGift(self)

	local gaveBomb
	local gaveShuriken
	local gavePowerUp
	local pos = go.get_position()
	local level = go.get("/player#player_script","suit_level")

	-- Potential for three gifts
	for i = 1, 3 do
		-- Give out a gift is needed
		local gift = math.random(10)

		-- Testing for gift type
		if gift >= 8 then
			if data.info.bomb.min < 5 and not gaveBomb then
				gaveBomb = true
				gift = "bomb"
			elseif data.info.shuriken.min < 15 and not gaveShuriken then
				gaveShuriken = true
				gift = "shuriken"
			elseif level == 1 and not gavePowerUp then
				gavePowerUp = true
				gift = "power_up"
			else
				break
			end

			-- Create a gift dynamically for the player
			factory.create( "#gifts", vmath.vector3(pos.x, pos.y + 90, pos.z + 0.001), nil,
			{ 
				direction = -self.direction,
				sprite = hash(gift)
			},	1)
		end	
	end
end




-- DEBUG
function spawn_dot(self, pos)
	return factory.create("#dots", vmath.vector3(pos.x, pos.y, 0.3), nil, {}, .25)
end

-- DEBUG
function update_dots(self, bpos)
	local dots = {}
	local iterations = 40 -- number of dots to make along projection line
	local projectTime = 1 -- seconds into the future to project trajectory
	local step = projectTime / iterations

	for i=1, iterations do
		table.insert(dots, spawn_dot(self, bpos))
	end

	for i, dot in ipairs(dots) do
		local t = i*step -- time to project into the future, for this dot
		local pos = vmath.vector3(bpos)

		pos.x = pos.x + self.velocity.x * t -- x velocity is not affected by gravity
		pos.y = pos.y + self.velocity.y * t + .5 * gravity * t * t -- y = initalV*t + 1/2 G*t-squared
		pos.z = 0.1
		go.set_position(pos, dot)
	end

	timer.delay(3, false, 
	function()
		for i, dot in ipairs(dots) do
			go.delete(dots)
		end
	end)
end


----------------------------------------------------------------------------
--
-- Required for Task: type, evaluator (function to call)
-- All other args will be added to the table as value.
-- IE: 'waypoints' not defined but expected. 
--	   arg# (arg1, arg2, etc) = { name = 'entry's name", value = "entry's value" or #value }
-- Exaple: { nodeType = "task", evaluator = moveToBird, arg1 = { name = "waypoints", value = self.waypoints }, arg2 = { name = "hp", value = 20 } }
--
----------------------------------------------------------------------------
local function SetupTree(self)

	-- Build a tree that controls majority of the boss' actions
	local treeBuilder = {
		nodeType = "selector",  -- This is the root node
		children = { 
			[1] = {
				-- If the above fails, default to the below
				nodeType = "selector",
				children = {
					-- Deflection and defense tasks
					[1] = { nodeType = "task", evaluator = deflectWeapon }, -- Can the boss deflect a weapon?
					[2] = { nodeType = "task", evaluator = defendExplosion }, -- Can the boss defend against an explosion?
					[3] = { nodeType = "task", evaluator = throwBomb }, -- Throw weapon instead? Must standing higher than the player
										
					-- Attacking tasks
					[1] = { nodeType = "task", evaluator = attackPlayer }, -- Can we attack the player? Must be close enough
					[2] = { nodeType = "task", evaluator = throwWeapon }, -- Throw weapon instead? Must be on ground level										
					[3] = { nodeType = "task", evaluator = throwBomb }, -- Throw weapon instead? Must standing higher than the player
				}
			},

			[2] = {	
				nodeType = "sequence", 
				children = { 
					[1] = { nodeType = "task", evaluator = moveToBird, arg1 = { name = "waypoints", value = self.waypoints } },
					[2] = { nodeType = "task", evaluator = eatBirdSeed }
				},
			} 						
		}
	}

	return node.new(treeBuilder)
end


------------------------------------------------------------------
--
-- Init code
--
------------------------------------------------------------------
function init(self)

	-- Start off facing left
	--self.direction = -1
	changeDirection(self, self.direction)

	-- Speed cannot be less that 3
	if self.speed < 3 then self.speed = 3 end

	-- 4 times normal speed
	self.pursuitSpeed = self.speed * 2
	self.runSpeed = self.speed * 1.5
	self.walkSpeed = self.speed


	-- Initial player velocity -- facing left
	self.velocity = vmath.vector3()
	--self.move = vmath.vector3(-self.speed, 0, 0)
	self.move = vmath.vector3(0, 0, 0)
	self.forced_move = vmath.vector3()	

	-- Support variable to keep track of collisions and separation
	self.correction = vmath.vector3()
	-- if the enemy stands on ground or not
	self.ground_contact = false
	-- If the enemy has jump abilities or not
	self.is_running = false

	-- The currently playing animation
	self.anim = nil	
	self.attack_anim = nil	
	-- When defeated, flash timer
	self.invulnerable = 0
	-- Enabled flag
	self.is_enabled = nil	
	-- Starting status 
	self.status = STATE_IDLE

	-- Shurikens can stun the boss after three consecutives hits.
	-- A bomb that connects resets the counter
	self.shurikenHits = 0
	-- List of timers to cancel
	--self.confused_timers = {}	

	-- Visibility
	msg.post("#sprite", (self.visible == true and "enable" or "disable"))
	msg.post("#health", (self.visible == true and "enable" or "disable"))

	-- Set the health bar
	sprite.set_constant("#health", "value", vmath.vector4(1.0))
	-- Get the size of a single HP for the bar

	local size = go.get("#health", "size")
	self.tick = (100 / self.hp)
	self.health_bar = 100

	-------------------------------
	-- Linked targets
	-------------------------------
	if self.path_id == -1 then
		self.path_id = nil
	end		
	if self.start_stage == -1 then
		self.start_stage = nil
	end		

	-- DEBUG ONLY
	self.pos = go.get_position()

	-- Randomizer seed
	math.randomseed(os.clock())
end


------------------------------------------------------------------
--
-- Method called each cycle
--
------------------------------------------------------------------
function fixed_update(self, dt)

	if not self.is_enabled or data.gameIsPaused or data.timer_inactive then return end	

	-- Call the update function so it triggers a constant Evaluation()	
	if self.root then
		-- Need to track dt
		node.dt = dt				
		-- Call the Tree's update function
		local terminate = self.root:update()
		if terminate == -1 then
			print("Terminated!")
			self.root = nil
		end		
	end

	--local pos = go.get_position() + self.move + self.forced_move
	local pos = go.get_position()

	-- 	-- If dt is > 0.01 (60 fps) or 0.02 (50 fps), don use data
	-- 	if dt > 0.02 then 
	-- 		self.velocity.y = 0
	-- 		return
	-- 	end
	-- 
	-- 	-------------------------------------
	-- 	-- Actions that occur on intervals
	-- 	-------------------------------------
	-- 	--if self.status == STATE_IDLE and not self.is_charging and not self.is_prsuing then
	-- 	if self.status == STATE_IDLE then
	-- 
	-- 		----------------------------------------------		
	-- 		-- Allow a throw when time limit > 2 seconds
	-- 		-- OR does not exist
	-- 		----------------------------------------------
	-- 		if self.time_limit and self.time_limit > 2 then
	-- 
	-- 			-- MUST be on the ground
	-- 			if self.ground_contact == true then
	-- 				if bit.band(self.actions, THROW_BOMB) > 0 then 
	-- 					if self.throw_counter <= 0 then
	-- 						--print("BOSS Update: Throw a bomb!")
	-- 						--
	-- 						stateThrowBomb(self, go.get_position("/player"))
	-- 						self.throw_counter = math.random(self.rules.throw_bomb_interval, self.rules.throw_bomb_interval + 2)
	-- 					end
	-- 					self.throw_counter = self.throw_counter - dt
	-- 
	-- 				elseif bit.band(self.actions, THROW_WEAPON) > 0 then 
	-- 					if self.throw_counter <= 0 then
	-- 						--print("BOSS Update: Throw a weapon!")
	-- 						--
	-- 						stateThrowWeapon(self, go.get_position("/player"))
	-- 						self.throw_counter = math.random(self.rules.throw_weapon_interval, self.rules.throw_weapon_interval + 2)
	-- 					end
	-- 					self.throw_counter = self.throw_counter - dt
	-- 				end
	-- 			end			
	-- 		end
	-- 
	-- 		---------------------------------------
	-- 		-- Time allowed per stage
	-- 		---------------------------------------
	-- 		if self.time_limit then	
	-- 			self.time_limit = self.time_limit - dt
	-- 			--
	-- 			if self.time_limit <= 0 then
	-- 				-- Can only transition when idle
	-- 				if self.status == STATE_IDLE then
	-- 					--self.time_limit = nil				
	-- 					stateSetTheStage(self, self.stage_index)
	-- 				else
	-- 					self.time_limit = self.time_limit + dt
	-- 				end
	-- 			end
	-- 		end
	-- 	end
	-- 
	-- 	--------------------------------------
	-- 	-- Use self.anim as the status for the
	-- 	-- finite state machine. Meh...
	-- 	--------------------------------------
	-- 	if self.anim == hash(self.enemy .. "_fall") then
	-- 		--if self.status == STATE_FALL then
	-- 		if self.ground_contact == true then
	-- 
	-- 			if self.status == STATE_PURSUING then				
	-- 				stateRun(self, self.pursuitSpeed)
	-- 
	-- 			elseif self.status == STATE_STAGING then				
	-- 				if self.stage_co then 
	-- 					coroutine.resume(self.stage_co)
	-- 				end				
	-- 				-- Boss hit the wall
	-- 			elseif self.status == STATE_HIT_WALL and self.hitwall_co then 
	-- 				coroutine.resume(self.hitwall_co)
	-- 			elseif self.status == STATE_IDLE then 
	-- 				stateIdle(self, true)
	-- 			end
	-- 
	-- 			-- Resume the intro coroutine if it exist
	-- 			if self.intro_co then 
	-- 				coroutine.resume(self.intro_co)
	-- 			end
	-- 		end
	-- 
	-- 		-- 	elseif self.anim == hash(self.enemy .. "_die") and self.status ~= STATE_DEAD then
	-- 		-- 
	-- 		-- 		if self.hitwall_co and self.ground_contact == true then 
	-- 		-- 			coroutine.resume(self.hitwall_co)
	-- 		-- 		end		
	-- 	end
	-- 
	---------------------------------------
	-- Adjust Boss position in the air
	---------------------------------------
	self.velocity.y = self.velocity.y + (gravity * dt)

	-- Determine if performing a 'STAGE' jump
	-- if self.status == STATE_STAGING then
	-- 	-- Parabola arc
	-- 	pos.x = pos.x + self.velocity.x * dt
	-- 	pos.y = pos.y + self.velocity.y * dt + 0.5 * gravity * dt * dt
	-- else
	pos.y = (pos.y + self.velocity.y * dt)	
	pos = pos + self.move + self.forced_move		
	--	end
	go.set_position(pos)

	-- 
	-- 	--------------------------------------------	
	-- 	-- Check to see if in pursuit of the player 
	-- 	--------------------------------------------
	-- 	checkForPursuit(self)
	-- 	-- Update animations based on state (ground, air, move and idle)	
	-- 	update_animations(self)
	-- 	-- Flash if hit by an attack
	-- 	flash(self)

	----------------------------------
	-- Reset verical velocity once 
	-- touching a ground surface
	----------------------------------
	if self.ground_contact == true then
		self.velocity.y = 0
	end

	-- Reset ground flag
	self.ground_contact = false

	-- reset volatile state
	self.correction.x, self.correction.y, self.correction.z = 0, 0, 0
	self.forced_move.x, self.forced_move.y, self.forced_move.z = 0, 0, 0
	self.wall_contact = false
end


----------------------------------------------------------------------------------------
--
--
-- Code that handles boss entrance
-- 
--
----------------------------------------------------------------------------------------
local function bossDropIn(self)

	-- Do we still need to process this node?
	if self.task_complete then
		return node.SUCCESS
	end

	-- One time touches
	if not self.is_active then
		-- Stop the game clock. Boss areas aren't under timer presure
		msg.post("/gui#game_hud", "timer_control", { pause = true } )
		-- Zoom the camera out a little
		go.animate("/camera#camera_script", "zoom", go.PLAYBACK_ONCE_FORWARD, .55, go.EASING_OUTQUAD, 1, .5)
		-- Freeze the player for now
		msg.post("/player", "set_control", { enable = false, animation = "idle" } )	
		-- Make boss visible
		msg.post("#sprite", "enable")
		msg.post("#health", "enable")		
		-- Stop the BG music
		data.music({ stop_all = true } )
		-- Move the camera to the boss to see falling
		cam.follow(CAMERA_ID, go.get_id(), { } )		
		-- Enable the Boss [ to fall in ], set the starting animation
		timer.delay(.5, false, 
		function()
			play_animation(self, hash(self.enemy .. "_fall"))
		end)		
		--
		self.is_active = true
		return node.RUNNING		
	end

	-- Task will loop until a ground contact is made
	local gc = go.get("#enemy_script", "ground_contact")
	if gc == true then
		self.task_complete = true
		return node.SUCCESS
	end

	return node.RUNNING
end


--------------------------------------------
--
--------------------------------------------
local function setBossScene(self)

	-- Do we still need to process this node?
	if self.task_complete then
		return node.SUCCESS
	end

	-- One time touches
	if not self.is_active then
		-- Ground effects
		showJumpDust("land")
		-- Boss is on the ground. Shake the screen
		cam.shake(CAMERA, 0.05, 0.5, "both", nil)
		sound.play("main:/sfx_group#bomb_explode", { speed = 1 })
		-- Bounce the player
		msg.post("/player", "thrust", { force = vmath.vector3(0, 96, 0) } )
		-- Immediately show idling
		sprite.play_flipbook("#sprite", hash(self.enemy .. "_idle" ))
		-- Pause a bit for effect. Then run the attack animations
		self.timer = 1
		self.is_active = true
		return node.RUNNING
	end

	-- Wait out the timer before moving on
	self.timer = self.timer - node.dt
	if self.timer <= 0 then
		self.task_complete = true
		return node.SUCCESS
	end

	return node.RUNNING
end


--------------------------------------------
--
--------------------------------------------
local function makeBossDance(self)

	-- Do we still need to process this node?
	if self.task_complete then
		return node.SUCCESS
	end

	----------------------------------------
	-- One time touches: Scene 1
	----------------------------------------
	if not self.scene_1_complete then
		-- Each scene has a timer
		if self.timer then
			self.timer = self.timer - node.dt
			if self.timer <= 0 then
				self.scene_1_complete = true
				self.timer = nil
			end
			return node.RUNNING			
		end

		-- Player needs to be on the ground for the full 'THRUST' effect
		go.set("/player#player_script", "ground_contact", true)
		-- Delayed sound for stab effect animation
		timer.delay(.2, false, 
		function()
			local dir = go.get("#enemy_script", "direction")
			msg.post("/player", "set_control", { enable = false, animation = "crouch" } )			
			msg.post("/player", "thrust", { direction = dir, force = vmath.vector3(2, 0, 0) } )
		end)
		-- Sound effect
		sound.play("main:/sfx_group#boss_stab", { gain = .5, delay = 0.2} )
		cam.shake(CAMERA, 0.015, 0.15, "both", nil)			
		-- Play animation 
		sprite.play_flipbook("#sprite", hash(self.enemy .. "_stab"),
		function()
			sprite.play_flipbook("#sprite", hash(self.enemy .. "_idle"))
		end)
		-- A little pause for effect
		self.timer = 1
		return node.RUNNING
	end

	----------------------------------------
	-- One time touches: Scene 2
	----------------------------------------
	if not self.scene_2_complete then
		-- Each scene has a timer
		if self.timer then
			self.timer = self.timer - node.dt
			if self.timer <= 0 then
				self.task_complete = true
				self.scene_2_complete = true
				self.timer = nil
				-- All done
				return node.SUCCESS
			end
			return node.RUNNING			
		end

		-- Delayed response to the next 'dance'
		timer.delay(.2, false, 
		function()
			local dir = go.get("#enemy_script", "direction")
			msg.post("/player", "set_control", { enable = false, animation = "hurt" } )					
			msg.post("/player", "thrust", { direction = dir, force = vmath.vector3(2, 0, 0) } )
		end)
		-- Dance for the camera
		sound.play("main:/sfx_group#bomb_explode", { speed = 1.5, delay = 0.2 })
		cam.shake(CAMERA, 0.02, 0.25, "both", nil)
		sprite.play_flipbook("#sprite", hash(self.enemy .. "_smash"),
		function()
			sprite.play_flipbook("#sprite", hash(self.enemy .. "_idle"))
		end)
		-- A little pause for effect
		self.timer = .5
	end

	return node.RUNNING
end


--------------------------------------------
--
--------------------------------------------
local function begineBossFight(self)

	-- Do we still need to process this node?
	if self.task_complete then
		return node.SUCCESS
	end

	if self.timer then
		self.timer = self.timer - node.dt
		-- 
		if self.timer <= 0 then
			data.music({ song = "main:/music_group#boss", play = true })
			cam.follow(CAMERA_ID, "/player", { } )	
			--self.status = STATE_IDLE
			sprite.play_flipbook("#sprite", hash(self.enemy .. "_idle"))						
			-- This tree process is done. No longer required at all
			return node.TERMINATE
		end
		return node.RUNNING
	end

	-- Prepare to fight!
	sprite.play_flipbook("#sprite", hash(self.enemy .. "_idle") )
	-- Give the player back control
	timer.delay(.5, false, 
	function()
		msg.post("/player", "set_control", { enable = true, animation = "idle" } )			
	end)
	-- A little pause for effect
	self.timer = 1

	return node.RUNNING
end


------------------------------------------------------------------
--
-- Messaging
--
------------------------------------------------------------------
function on_message(self, message_id, message, sender)

	if message_id == hash("boss_intro") then

		-- Home offsets
		buildStageTable(self)

		-- Run the intro using a BT
		self.root = tree.start(self,
		function()
			local intro = {
				nodeType = "sequence",
				children = {
					[1] = { nodeType = "task", evaluator = bossDropIn, arg1 = { name = "enemy", value = self.enemy } }, -- Waits for ground contact
					[2] = { nodeType = "task", evaluator = setBossScene, arg1 = { name = "enemy", value = self.enemy } },
					[3] = { nodeType = "task", evaluator = makeBossDance, arg1 = { name = "enemy", value = self.enemy } },
					[4] = { nodeType = "task", evaluator = begineBossFight, arg1 = { name = "enemy", value = self.enemy } },
				}
			}
			return node.new(intro)
		end)

		--------------------------------
		if self.intro_stage then
			local stage_pos = self.stage_locs[self.intro_stage].pos
			local stage_actions = self.stage_locs[self.intro_stage].actions
			local direction = self.stage_locs[self.intro_stage].direction -- current not used
			local timeLimit = self.stage_locs[self.intro_stage].timeLimit
			local stage_index = self.stage_locs[self.intro_stage].linked_index

			-- Set new actions / rules /time limits
			self.actions = stage_actions
			self.time_limit = (timeLimit > 0) and timeLimit or nil
			self.stage_index = stage_index
			self.intro_stage = nil
		end			
		self.is_enabled = true

		-- Check if we received a contact point message
	elseif message_id == hash("setEnemy") then

		self.enemy = message.enemy
		self.actions = message.action.actions
		message.action.actions = nil
		self.rules = message.action

		local enemy = go.get("#enemy_script", message.enemy .. "_knight")
		go.set("#sprite", "image", enemy)

	elseif message_id == hash("setMessage") then

		self.message = message.message

	elseif message_id == hash("executed") then

		-- Show status message
		if self.message then
			msg.post("/gui#game_hud", "show_status", { text = self.message or "" })
		end

		--Linked object processed only once!
		self.path_id = nil

		-- Only called back when used as a trigger
		timer.delay(0.5, false,
		function()
			cam.follow(CAMERA_ID, "/player", { } )
			-- Restore player
			-- Freeze the player for now
			msg.post("/player", "set_control", { enable = true, animation = "idle" } )
			--			go.set("/player#player_script", "cannot_control", false)
			go.set("/player#player_script", "invulnerable", 100)

			-- Now delete
			go.delete()
		end)

	elseif message_id == hash("move") then

		self.forced_move = message.move

		--------------------------------------
		-- Trigger contact
		--------------------------------------
	elseif message_id == hash("trigger_response") and message.enter then

		-- Determine what attack to perform
		if (self.status == STATE_IDLE or self.status == STATE_CHARGING or self.status == STATE_PURSUING) then
			if message.other_group == hash("player") and message.own_group == hash("trigger") then

				local shield = go.get("/player#player_script", "invulnerable")				
				if shield <= 0 then 
					attackThePlayer(self)
				end			
				return true
			end
		end

		-- Handle weapons
		if self.status ~= STATE_CONFUSED and message.other_group ~= hash("player") then 
			local type = message.other_id
			local url = msg.url(nil, type, "weapon_script")
			local random = math.random(4)
			type = go.get(url, "type") or nil

			-- Deflections: Weapon touched #attack collider / trigger
			-- Shuriken or bomb 
			if message.own_group == hash("trigger") and message.other_group == hash("weapon") then
				-- Defend test or deflect test
				-- Try to deflect
				stateDeflect(self, type, url)
				--stateHurt(self, type)
				--else
				--stateDefend(self, type)
				--end

			elseif message.own_group == hash("enemy") and message.other_group == hash("weapon") then
				-- Detonation of a bomb or shuriken was not deflected
				-- Only shuriken will for sure hit the boss enemy
				if type == hash("bomb") then
					-- 	stateHurt(self, type)
					-- else
					stateDefend(self, type)
				end
			end
		end			

		--------------------------------------
		-- Kinematic contact
		--------------------------------------
	elseif message_id == hash("contact_point_response") then	

		-- check that the object is something we consider an obstacle
		if message.group == hash("ground") then

			handle_obstacle_contact(self, message.normal, message.distance)
		end

	elseif message_id == hash("collision_response") then			

		if message.other_group == hash("player") and message.own_group == hash("enemy") then

			-- Only chance to hurt the boss. Do so once
			if not self.boss_hit and self.status == STATE_CONFUSED then
				local anim = go.get("/player#player_script", "anim")

				-- If the player is falling ANYWHERE near the boss' kinematic body, hurt'em!
				if anim == hash("fall") or anim == hash("hood_fall") then 
					-- Player responds to the stop and jums off the boss
					msg.post("/player", "jump", { spring = 1 } )
					-- Show the stomp
					flashWhackEffect(self)
					-- Cause damage
					stateHurt(self, nil)
					-- Set flag indicating Boss was hit
					self.boss_hit = true
					--print("Boss tapped!")
				end

				-- Boss touching the player hurts the player
			elseif not self.boss_hit then

				local shield = go.get("/player#player_script", "invulnerable")

				-- Can the player be hit
				if shield <= 0 then
					msg.post("/player", "hurt", { hit = true } )
					-- If the player was hurt, return home
					--if self.is_charging then
					if self.status == STATE_CHARGING then
						stateIdle(self)  -- Stop running / walking
						stateGotoTheStage(self)
					end
				end
			end

			-- Shuriken passed thru #attack collider and now hitting the enamy
		elseif message.own_group == hash("enemy") and message.other_group == hash("weapon") then
			-- Detonation of a bomb or shuriken was not deflected
			-- Only shuriken will for sure hit the boss enemy
			local type = message.other_id
			local url = msg.url(nil, type, "weapon_script")
			type = go.get(url, "type") or nil

			if type == hash("shuriken") then
				stateHurt(self, type)
			end
		end
	end
end


function on_reload(self)
	self.is_enabled = false
	go.set_position(self.pos)

	msg.post(".", "boss_intro")
end
